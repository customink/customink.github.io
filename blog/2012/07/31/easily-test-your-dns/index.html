<!DOCTYPE html>
<html>
  <head>
  <title>Easily test your DNS - CustomInk Technology Blog</title>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <meta name="description" content="At CustomInk, we recently made the switch to a new DNS provider. During the switch, we mass-imported records from our existing provider to our new ...">
  <link rel="alternate" type="application/rss+xml" title="RSS" href="http://technology.customink.com/feed.xml" />
  <link rel="stylesheet" href="/assets/app-1193f26ffafc82796d02d27f7d8607d4.css">
  <script type="text/javascript">
  (function(d) {
    var config = {
      kitId: 'tph7yyf',
      scriptTimeout: 3000
    },
    h=d.documentElement,t=setTimeout(function(){h.className=h.className.replace(/\bwf-loading\b/g,"")+" wf-inactive";},config.scriptTimeout),tk=d.createElement("script"),f=false,s=d.getElementsByTagName("script")[0],a;h.className+=" wf-loading";tk.src='//use.typekit.net/'+config.kitId+'.js';tk.async=true;tk.onload=tk.onreadystatechange=function(){a=this.readyState;if(f||a&&a!="complete"&&a!="loaded")return;f=true;clearTimeout(t);try{Typekit.load(config)}catch(e){}};s.parentNode.insertBefore(tk,s)
  })(document);
</script>

  
</head>

  <body class="tb-Post">
    <header class="tb-Header">
  <div class="sb-Wrapper">
    <nav class="tb-Header-home">
      <a href="/" class="tb-Header-home-logo"><img src="/assets/CustomInk_Tech_Color-f9e81e9def04cfa2ba39d06ee8e218e4.png"></a>
    </nav>
    <input type="checkbox" id="tb-Header-toggle" />
    <div class="tb-Header-area">
      <label for="tb-Header-toggle" class="tb-Header-toggle" data-open="Menu" data-close="Close" onclick></label>
      <ul class="tb-Header-menu">
        <li class="tb-Header-menu-item">
        
          <a href="/team" class="tb-Header-menu-link">AUTHORS</a>
        
        </li>
        <li class="tb-Header-menu-item">
          <a href="http://customink.com" class="tb-Header-menu-link">CUSTOMINK.COM</a>
        </li>
      </ul>
    </div>
  </div>
</header>

    <div class="tb-Post-main sb-Wrapper">
      <div class="tb-Post-content">
        <h1>Easily test your DNS</h1>
        <p>At CustomInk, we recently made the switch to a new DNS provider. During the switch, we mass-imported records from our existing provider to our new provider. Did we get them all? Are they live yet? The immediate solution was to open up the terminal and fire off cURL requests, but there had to be a better way...</p>

<p>In this post/tutorial, I will show you how I created a test suite for our DNS records using RSpec. The solution is amazingly simple, and your specs will only be about 7 lines of code!</p>

<!--more-->

<h2 id="the-end-result">The End Result</h2>

<p>I don&#39;t often do this, but to demonstrate just how awesome these tests are going to be, here is a final example spec:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="nb">require</span> <span class="s1">'spec_helper'</span>

<span class="n">describe</span> <span class="s1">'www.customink.com'</span> <span class="k">do</span>
  <span class="n">expects</span> <span class="ss">ttl: </span><span class="mi">300</span><span class="p">,</span> <span class="ss">type: </span><span class="s1">'A'</span><span class="p">,</span> <span class="ss">value: </span><span class="s1">'1.2.3.4'</span>
<span class="k">end</span>
</code></pre></div>
<h2 id="getting-started">Getting Started</h2>

<p>As with any Ruby-based project, there&#39;s some initial setup. Generate a new project and create a <code>Gemfile</code> with the following content:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">source</span> <span class="ss">:rubygems</span>

<span class="n">gem</span> <span class="s1">'rspec'</span><span class="p">,</span> <span class="s1">'~&gt; 2.11.0'</span>
</code></pre></div>
<p>Don&#39;t forget to run the <code>bundle</code> command to install the gems:</p>
<div class="highlight"><pre><code class="language-" data-lang="">$ bundle
</code></pre></div>
<p>Next, create a folder named <code>spec</code> in your project directory and then create a <code>spec/spec_helper.rb</code> file with the following content:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="nb">require</span> <span class="s1">'rspec'</span>
<span class="nb">require</span> <span class="s1">'resolv'</span>

<span class="nb">require</span> <span class="s1">'spec/macros/zones_macro'</span>

<span class="no">RSpec</span><span class="p">.</span><span class="nf">configure</span> <span class="k">do</span> <span class="o">|</span><span class="n">config</span><span class="o">|</span>
  <span class="n">config</span><span class="p">.</span><span class="nf">tty</span> <span class="o">=</span> <span class="kp">true</span>
  <span class="n">config</span><span class="p">.</span><span class="nf">include</span> <span class="no">ZonesMacro</span>
<span class="k">end</span>
</code></pre></div>
<p>There are a few things to cover here:</p>

<ol>
<li>We are requiring <code>resolv</code>, which is a Ruby 1.9 library for resolving DNS queries (it&#39;s like <code>dig</code> on steroids). Here is the <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/resolv/rdoc/">official documentation for resolv</a>.</li>
<li>We require our custom macro - <code>ZonesMacro</code>.</li>
<li>Lastly, we enable <code>tty</code> so that we get colored output on our CI server and include our <code>ZoneMacro</code>.</li>
</ol>

<h2 id="writing-zonemacro">Writing <code>ZoneMacro</code></h2>

<p>The <code>ZoneMacro</code> is where the &quot;hardest&quot; of our logic will live. That being said, it&#39;s not very complicated.</p>

<p>Create the <code>macros/zones_macro.rb</code> file and start with the &quot;boiler-plate&quot; macro:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">module</span> <span class="nn">ZonesMacro</span>
  <span class="k">module</span> <span class="nn">ClassMethods</span>
  <span class="k">end</span>

  <span class="k">module</span> <span class="nn">InstanceMethods</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">included</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
    <span class="n">base</span><span class="p">.</span><span class="nf">extend</span><span class="p">(</span><span class="no">ClassMethods</span><span class="p">)</span>
    <span class="n">base</span><span class="p">.</span><span class="nf">send</span> <span class="ss">:include</span><span class="p">,</span> <span class="no">InstanceMethods</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>
<p>In the context of RSpec (no pun intended), <code>ClassMethods</code> are things directly inside a <code>describe</code> block, and <code>InstanceMethods</code> are things inside an <code>it</code> declaration.</p>

<p>If you look back at our earlier example, you can see that we actually want <code>ClassMethods</code> for our <code>expects</code> method:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nf">expects</span><span class="p">(</span><span class="n">expected</span> <span class="o">=</span> <span class="p">{})</span>
  <span class="n">matched_records</span> <span class="o">=</span> <span class="n">records</span><span class="p">.</span><span class="nf">select</span> <span class="k">do</span> <span class="o">|</span><span class="n">record</span><span class="o">|</span>
    <span class="n">record</span><span class="p">.</span><span class="nf">type</span> <span class="o">==</span> <span class="n">expected</span><span class="p">[</span><span class="ss">:type</span><span class="p">].</span><span class="nf">upcase</span> <span class="o">&amp;&amp;</span>
    <span class="n">record</span><span class="p">.</span><span class="nf">ttl</span> <span class="o">==</span> <span class="n">expected</span><span class="p">[</span><span class="ss">:ttl</span><span class="p">].</span><span class="nf">to_i</span> <span class="o">&amp;&amp;</span>
    <span class="n">record</span><span class="p">.</span><span class="nf">value</span><span class="p">.</span><span class="nf">include?</span><span class="p">(</span><span class="n">expected</span><span class="p">[</span><span class="ss">:value</span><span class="p">].</span><span class="nf">upcase</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="n">it</span> <span class="s2">"should have the correct DNS entry"</span> <span class="k">do</span>
    <span class="n">matched_records</span><span class="p">.</span><span class="nf">should_not</span> <span class="n">be_empty</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>
<p>So what is <code>records</code>? Well, we need to define it. Because <code>records</code> exists outside an <code>it</code> block, the declaration needs to go inside the <code>ClassMethods</code> module:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="kp">private</span>
<span class="k">def</span> <span class="nf">records</span>
  <span class="vi">@records</span> <span class="o">||=</span> <span class="k">begin</span>
    <span class="no">Timeout</span><span class="o">::</span><span class="n">timeout</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="no">Resolv</span><span class="o">::</span><span class="no">DNS</span><span class="p">.</span><span class="nf">new</span><span class="p">.</span><span class="nf">getresources</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="nf">display_name</span><span class="p">,</span> <span class="no">Resolv</span><span class="o">::</span><span class="no">DNS</span><span class="o">::</span><span class="no">Resource</span><span class="o">::</span><span class="no">IN</span><span class="o">::</span><span class="no">ANY</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="k">rescue</span> <span class="no">Timeout</span><span class="o">::</span><span class="no">Error</span> <span class="o">=&gt;</span> <span class="n">e</span>
    <span class="vg">$stderr</span><span class="p">.</span><span class="nf">puts</span> <span class="s2">"Connection timed out for </span><span class="si">#{</span><span class="nb">self</span><span class="p">.</span><span class="nf">display_name</span><span class="si">}</span><span class="s2">"</span>
    <span class="p">[]</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>
<p>We add the <code>Timeout::timeout</code> so that resources that cannot be reached timeout in a reasonable amount of time.</p>

<p>Most of that is directly out of the <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/resolv/rdoc/">Resolv Documentation</a>, except for the <code>self.class.display_name</code>. This is provided by RSpec, and it&#39;s the value of the <code>describe</code> block.</p>

<p>In other words:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">describe</span> <span class="s1">'This is the self.display_name'</span> <span class="k">do</span>
  <span class="c1"># ...</span>
<span class="k">end</span>
</code></pre></div>
<p>The <code>Resolv</code> block will make a DNS query to the <code>display_name</code>. Notice that we are returning an array of resources. You may also see a method called <code>getresource</code> (singular) for <code>Resolve::DNS</code> that returns only the first resource. If you have multiple records for the same key (like an A record and an MX record), your tests will not pass, because <code>getresource</code> just grabs the first record it sees...</p>

<p>We are also searching for a <code>resource_type</code> of <code>ANY</code>. This doesn&#39;t really matter because we are caching the result, and we are also already checking the type of the record returned.</p>

<p>If you run this right now, you&#39;ll get a lot of <code>undefined method</code> errors. That&#39;s because I also monkey-patched <code>Resolv::DNS::Resource</code> to return normalized data:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">Resolv</span><span class="o">::</span><span class="no">DNS</span><span class="o">::</span><span class="no">Resource</span>
  <span class="k">def</span> <span class="nf">value</span>
    <span class="sx">%w(address data exchange name target)</span><span class="p">.</span><span class="nf">collect</span> <span class="k">do</span> <span class="o">|</span><span class="n">key</span><span class="o">|</span>
      <span class="nb">self</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="n">key</span><span class="p">.</span><span class="nf">to_sym</span><span class="p">).</span><span class="nf">to_s</span><span class="p">.</span><span class="nf">upcase</span> <span class="k">if</span> <span class="nb">self</span><span class="p">.</span><span class="nf">respond_to?</span><span class="p">(</span><span class="n">key</span><span class="p">.</span><span class="nf">to_sym</span><span class="p">)</span>
    <span class="k">end</span><span class="p">.</span><span class="nf">compact</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">type</span>
    <span class="nb">self</span><span class="p">.</span><span class="nf">class</span><span class="p">.</span><span class="nf">name</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="s1">'::'</span><span class="p">).</span><span class="nf">last</span><span class="p">.</span><span class="nf">upcase</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>
<h2 id="dynamically-writing-tests">Dynamically Writing Tests</h2>

<p>We have 500+ DNS records, so manually writing all of those tests was also a daunting task. Of course, I scripted it. You can get an export file of your current configuration from your DNS provider. The format may vary, but here&#39;s the simple little script I wrote to automatically generate all our tests.</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="c1"># `config` is the existing DNS configuration file</span>
<span class="n">config</span> <span class="o">=</span> <span class="no">File</span><span class="p">.</span><span class="nf">readlines</span><span class="p">(</span><span class="s1">'/Users/svargo/Desktop/config'</span><span class="p">)</span><span class="o">.</span>

<span class="c1"># For each line, split on a space, remove the drunk, and</span>
<span class="c1"># create a hash for easy access.</span>
<span class="n">collect</span> <span class="k">do</span> <span class="o">|</span><span class="n">line</span><span class="o">|</span>
  <span class="nb">split</span> <span class="o">=</span> <span class="n">line</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="s1">' '</span><span class="p">).</span><span class="nf">collect</span><span class="p">{</span> <span class="o">|</span><span class="n">l</span><span class="o">|</span> <span class="n">l</span><span class="p">.</span><span class="nf">strip</span><span class="p">.</span><span class="nf">chomp</span><span class="p">(</span><span class="s1">'.'</span><span class="p">)</span> <span class="p">}</span>
  <span class="p">{</span> <span class="ss">:url</span> <span class="o">=&gt;</span> <span class="nb">split</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="ss">:ttl</span> <span class="o">=&gt;</span> <span class="nb">split</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="ss">:type</span> <span class="o">=&gt;</span> <span class="nb">split</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="ss">:data</span> <span class="o">=&gt;</span> <span class="nb">split</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="p">}</span>
<span class="k">end</span>

<span class="c1"># For each record, write out the spec and expected results.</span>
<span class="c1"># I had to massage some data using `gsub` because of inconsistent formatting.</span>
<span class="n">config</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">record</span><span class="o">|</span>
  <span class="n">str</span> <span class="o">=</span> <span class="o">&lt;&lt;-</span><span class="no">EOH</span><span class="sh">
require 'spec_helper'

describe '</span><span class="si">#{</span><span class="n">record</span><span class="p">[</span><span class="ss">:url</span><span class="p">]</span><span class="si">}</span><span class="sh">' do
  expects ttl: </span><span class="si">#{</span><span class="n">record</span><span class="p">[</span><span class="ss">:ttl</span><span class="p">]</span><span class="si">}</span><span class="sh">, type: '</span><span class="si">#{</span><span class="n">record</span><span class="p">[</span><span class="ss">:type</span><span class="p">]</span><span class="si">}</span><span class="sh">', value: '</span><span class="si">#{</span><span class="n">record</span><span class="p">[</span><span class="ss">:data</span><span class="p">].</span><span class="nf">gsub</span><span class="p">(</span><span class="s1">'"'</span><span class="p">,</span> <span class="s1">''</span><span class="p">)</span><span class="si">}</span><span class="sh">'
end
</span><span class="no">EOH</span>

  <span class="c1"># Write the spec to the proper file</span>
  <span class="no">File</span><span class="p">.</span><span class="nf">open</span><span class="p">(</span><span class="s2">"spec/units/</span><span class="si">#{</span><span class="n">record</span><span class="p">[</span><span class="ss">:url</span><span class="p">]</span><span class="si">}</span><span class="s2">_spec.rb"</span><span class="p">,</span> <span class="s1">'w'</span><span class="p">){</span> <span class="o">|</span><span class="n">f</span><span class="o">|</span> <span class="n">f</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="n">str</span><span class="p">)</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre></div>
<p>Needless to say, this saved a significant amount of time and energy.</p>

<h2 id="add-to-ci">Add to CI</h2>

<p>I created a quick Jenkins job for these specs and set them to run every 15 minutes. Super simple and reliable CI for our DNS entires. Now, we can easily spot outdated records or problem servers.</p>

<h2 id="a-question-of-completeness">A Question of Completeness?</h2>

<dl>
  <dt>Q: Is this a complete solution?</dt>
  <dd>A: No</dd>
</dl>

<p><br></p>

<p>While this solution is expandable, it&#39;s far from complete. That being said, do you really require 100% coverage for all your DNS entires? It was very useful to have 100% coverage here, because we were migrating from our existing provider entirely. If you are writing these specs as &quot;health checks&quot;, you will probably have significantly less...</p>

<p>This is definitely not a replacement for solutions like New Relic or other monitoring software, but it&#39;s an excellent homegrown solution in under 2 hours.</p>

<h2 id="disclaimer">Disclaimer</h2>

<p>This post was written using Ruby 1.9.3. It should work on Ruby 1.9.x, but I guarantee it won&#39;t work on 1.8.7.</p>

      </div>
      

<div class="tb-Author">
  
  <div class="tb-Author-info">
    <time pubdate datetime="2012-07-31T01:31:00-04:00">
      31 Jul 2012
    </time></br>
    by Seth Vargo
    <div class="tb-Author-icons">
      
      
      
    </div>
  </div>
</div>

    </div>

    
  <div class="sb-Wrapper">
    <section id="disqus_thread">
    </section>
  </div>
  <script type="text/javascript">
    var disqus_shortname = 'custominktechnologyblog';
    var disqus_identifier = '/blog/2012/07/31/easily-test-your-dns/';
    var disqus_title = "Easily test your DNS";
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>


    <div class="tb-Footer">
  <div><small>&copy; 2016 CustomInk, LLC. All rights reserved.</small></div>
  <div><small><a href="http://customink.com">CustomInk</a> is a registered trademark of CustomInk LLC. "T-shirts Unite!" and the "Inky" octopus are trademarks of CustomInk, LLC.</small></div>
</div>

    
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-32456448-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


    <script src="/assets/app-c8c0da21cd353ed58196e02e376670a3.js"></script>
  </body>
</html>
