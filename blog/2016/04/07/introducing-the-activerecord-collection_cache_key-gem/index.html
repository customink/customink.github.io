<!DOCTYPE html>
<html>
  <head>
  <title>Introducing the activerecord-collection_cache_key Gem - CustomInk Technology Blog</title>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <meta name="description" content="Today we&#39;re releasing a backport gem of a new feature in Rails 5—cache keys for ActiveRecord collections. It tracks fairly closely with the imp...">
  <link rel="alternate" type="application/rss+xml" title="RSS" href="http://technology.customink.com/feed.xml" />
  <link rel="stylesheet" type="text/css" href="/assets/app-9fb5f199f67c50e99bda49998478901a6afd824fd2bd222f5562e57268788ecd.css">
</head>

  <body class="tb-Post">
    <header class="tb-Header">
  <div class="sb-Wrapper">
    <nav class="tb-Header-home">
      <a href="/" class="tb-Header-home-logo"><img src="/assets/CustomInk_Tech_Color-1460f9e847670e2626e66143266004749ab6c7204a8d5a2ae394613f986c473d.png"></a>
    </nav>
    <input type="checkbox" id="tb-Header-toggle" />
    <div class="tb-Header-area">
      <label for="tb-Header-toggle" class="tb-Header-toggle" data-open="Menu" data-close="Close" onclick></label>
      <ul class="tb-Header-menu">
        <li class="tb-Header-menu-item">
        
          <a href="/team" class="tb-Header-menu-link">AUTHORS</a>
        
        </li>
        <li class="tb-Header-menu-item">
          <a href="http://customink.com" class="tb-Header-menu-link">CUSTOMINK.COM</a>
        </li>
      </ul>
    </div>
  </div>
</header>

    <div class="tb-Post-main sb-Wrapper">
      <div class="tb-Post-content">
        <h1>Introducing the activerecord-collection_cache_key Gem</h1>
        <p>Today we&#39;re releasing a backport gem of a new feature in Rails 5—cache keys for ActiveRecord collections. It tracks fairly closely with the implementation seen <a href="https://github.com/rails/rails/pull/20884">in the Rails source</a> but has a few minor differences arising from support back to AR 3. We&#39;ve certainly been missing this feature for a long time and hope it comes in handy.</p>

<!--more-->

<p>Rails already has fairly advanced fragment caching available at the view layer—if you wanted to cache the rendered representation of a collection of objects, you could do something like this:</p>
<div class="highlight"><pre><code class="language-erb" data-lang="erb"><span class="nt">&lt;table&gt;</span>
  <span class="cp">&lt;%</span> <span class="n">cache</span> <span class="vi">@cached_things</span> <span class="k">do</span> <span class="cp">%&gt;</span>
    <span class="cp">&lt;%</span> <span class="vi">@cached_things</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">cached_thing</span><span class="o">|</span> <span class="cp">%&gt;</span>
      <span class="nt">&lt;tr&gt;</span>
        <span class="nt">&lt;td&gt;</span><span class="cp">&lt;%=</span> <span class="n">cached_thing</span><span class="p">.</span><span class="nf">name</span> <span class="cp">%&gt;</span><span class="nt">&lt;/td&gt;</span>
        <span class="nt">&lt;td&gt;</span><span class="cp">&lt;%=</span> <span class="n">cached_thing</span><span class="p">.</span><span class="nf">description</span> <span class="cp">%&gt;</span><span class="nt">&lt;/td&gt;</span>
        <span class="nt">&lt;td&gt;</span><span class="cp">&lt;%=</span> <span class="n">cached_thing</span><span class="p">.</span><span class="nf">status</span> <span class="cp">%&gt;</span><span class="nt">&lt;/td&gt;</span>
      <span class="nt">&lt;/tr&gt;</span>
    <span class="cp">&lt;%</span> <span class="k">end</span> <span class="cp">%&gt;</span>
  <span class="cp">&lt;%</span> <span class="k">end</span> <span class="cp">%&gt;</span>
<span class="nt">&lt;/table&gt;</span>
</code></pre></div>
<p>With caching enabled, you&#39;d see a fragment read/write in your console that looks something like the following:</p>

<p><code>views/cached_things/1-20160404161453044590000/cached_things/2-20160404161002789386000/fda68e69e4c5ced06fcdd5a88ebd2fe5</code></p>

<p>That key includes a few data points. There&#39;s a key for each record in the collection that includes the <code>id</code> and <code>updated_at</code> timestamp. There&#39;s also a digest of the template fragment&#39;s content, so the cache can be invalidated when the cached part of the template changes. This is pretty great, but it requires that each instance of <code>CachedThing</code> be initialized by ActiveRecord. As collection sizes grow this begins to significantly cut into the benefits of caching. Implementing <code>#cache_key</code> at the collection level allows us to cache upstream of AR object initialization, making rendering from cache a matter of linear time.</p>

<h3 id="installation">Installation</h3>

<p>Add it to your <code>Gemfile</code>:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">gem</span> <span class="s1">'activerecord-collection_cache_key'</span>
</code></pre></div>
<p>and run <code>bundle</code>. The gem will be autorequired and will augment <code>ActiveRecord::Base</code> with a <code>.collection_cache_key</code> method, as well as adding a <code>#cache_key</code> method to <code>Activerecord::Relation</code></p>

<h3 id="usage">Usage</h3>

<p>You can call <code>#cache_key</code> on any activerecord relation to get a deterministic key for use with the Rails cache interface, and caching of a response can be implemented at the controller layer for maximum performance gains:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nf">index</span>
  <span class="vi">@collection</span> <span class="o">=</span> <span class="no">CachedThing</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">status: </span><span class="s1">'published'</span><span class="p">)</span>
  <span class="no">Rails</span><span class="p">.</span><span class="nf">cache</span><span class="p">.</span><span class="nf">fetch</span><span class="p">(</span><span class="vi">@collection</span><span class="p">.</span><span class="nf">cache_key</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">respond_with</span><span class="p">(</span><span class="vi">@collection</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>
<p>This is a simplistic example; a real-world implementation would most likely need to handle things like response format, query params, or anything else that could manipulate the output in a unique way given the same collection. You&#39;ll be able to read all about how we&#39;re using it in an upcoming post.</p>

<h3 id="key-format">Key Format</h3>

<p>Cache keys look the same as the official Rails implementation:</p>

<p><code>#{model_name}/query-#{md5_digest}-#{collection_size}-#{timestamp}</code></p>

<p>Where the MD5 digest is a hash of the output of <code>Relation#to_sql</code>, and the timestamp is the most recent <code>updated_at</code> (or :timestamp_column of your choice) of the matching records in the collection.</p>

<h3 id="caveats">Caveats</h3>

<p>While keys from this gem follow the same format as the Rails implementation, they are not identical. There are three notable ways in which they differ:</p>

<ul>
<li><p>The SQL digest for full-collection caches includes <code>where (1 = 1)</code> in its source.</p>

<p>This is because in ActiveRecord 3, Model.all returns an instance of Array, not ActiveRecord::Relation. We can add a where clause to unbound collections to force the correct type.</p></li>
<li><p>The <code>collection_size</code> integer for limited queries will be the full collection size, not the size of the limited collection. </p>

<p>There are <a href="https://github.com/rails/rails/pull/20884#issuecomment-128910649">documented edge cases</a> where the key for a limited collection may not change when its contents do. We&#39;ve found that including the total size of the collection in the key and letting the sql digest handle uniqueness around limits and offsets suffices to yield properly deterministic caching.</p></li>
<li><p>The default <code>cache_timestamp_format</code> for Rails 3.2 is <code>:number</code> rather than <code>:nsec</code>.</p>

<p>This is because the <code>cache_timestamp_format</code> method was introduced in AR 3.2, but the <code>:nsec</code> formatter did not yet exist. For consistency with other keys in 3.2, we&#39;ve left the default untouched there. All other versions of AR will implement an <code>:nsec</code> formatter and use it as the default.</p></li>
</ul>

<h3 id="thats-it">That&#39;s it!</h3>

<p>Give <a href="https://github.com/customink/activerecord-collection_cache_key">the code a look</a>, try it out, and let us know what you think!</p>

      </div>
      <div class="tb-Post-author">
        
        
        <div class="tb-Author">
  
    <div class="tb-Author-gravatar">
      <img title="Dan Drinkard" src="http://www.gravatar.com/avatar/3bc10ad50945fe09663dd62218512299?s=150"/>
    </div>
  
  <div class="tb-Author-info">
    
      <time pubdate datetime="2016-04-07T00:00:00-04:00">
        07 Apr 2016
      </time></br>
      by Dan Drinkard
    
    <div class="tb-Author-icons">
      
        <span class="tb-Author-icon">
          <a href="http://twitter.com/drinks"><i class="tb-Icon-twitter"></i></a>
        </span>
      
      
        <span class="tb-Author-icon">
          <a href="https://github.com/drinks"><i class="tb-Icon-github"></i></a>
        </span>
      
      
    </div>
    
      <div class="tb-Author-posts">
        <a href="/authors/dan-drinkard" class="sb-Btn sb-Btn--secondary sb-Btn--small">
          View All Posts
        </a>
      </div>
    
  </div>
</div>

      </div>
    </div>
    
  <div class="sb-Wrapper">
    <section id="disqus_thread">
    </section>
  </div>
  <script type="text/javascript">
    var disqus_shortname = 'custominktechnologyblog';
    var disqus_identifier = '/blog/2016/04/07/introducing-the-activerecord-collection_cache_key-gem/';
    var disqus_title = "Introducing the activerecord-collection_cache_key Gem";
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>


    <div class="tb-Footer">
  <div><small>&copy; 2018 CustomInk, LLC. All rights reserved.</small></div>
  <div><small><a href="http://customink.com">CustomInk</a> is a registered trademark of CustomInk LLC. "T-shirts Unite!" and the "Inky" octopus are trademarks of CustomInk, LLC.</small></div>
</div>

    
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-32456448-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


    <script src="/assets/app-9b22a82c5e39b6e35faf56501565196c2778184fa749c44436f639b4986f61bc.js" type="text/javascript"></script>
  </body>
</html>
