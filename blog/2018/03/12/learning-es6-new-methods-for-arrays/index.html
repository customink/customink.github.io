<!DOCTYPE html>
<html>
  <head>
  <title>Learning ES6: New Methods for Arrays - CustomInk Technology Blog</title>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <meta name="description" content="In ES6, we get a bunch of new native methods for Arrays that are super useful! This is a short blog post that goes over each of the new methods - ....">
  <link rel="alternate" type="application/rss+xml" title="RSS" href="http://technology.customink.com/feed.xml" />
  <link rel="stylesheet" type="text/css" href="/assets/app-9fb5f199f67c50e99bda49998478901a6afd824fd2bd222f5562e57268788ecd.css">
</head>

  <body class="tb-Post">
    <header class="tb-Header">
  <div class="sb-Wrapper">
    <nav class="tb-Header-home">
      <a href="/" class="tb-Header-home-logo"><img src="/assets/CustomInk_Tech_Color-1460f9e847670e2626e66143266004749ab6c7204a8d5a2ae394613f986c473d.png"></a>
    </nav>
    <input type="checkbox" id="tb-Header-toggle" />
    <div class="tb-Header-area">
      <label for="tb-Header-toggle" class="tb-Header-toggle" data-open="Menu" data-close="Close" onclick></label>
      <ul class="tb-Header-menu">
        <li class="tb-Header-menu-item">
        
          <a href="/team" class="tb-Header-menu-link">AUTHORS</a>
        
        </li>
        <li class="tb-Header-menu-item">
          <a href="http://customink.com" class="tb-Header-menu-link">CUSTOMINK.COM</a>
        </li>
      </ul>
    </div>
  </div>
</header>

    <div class="tb-Post-main sb-Wrapper">
      <div class="tb-Post-content">
        <h1>Learning ES6: New Methods for Arrays</h1>
        <p>In ES6, we get a bunch of new native methods for Arrays that are super useful! This is a short blog post that goes over each of the new methods - <code>.from()</code>, <code>.of()</code>, <code>.find()</code>, <code>.findIndex()</code>, <code>.some()</code>, and <code>.every()</code> - and how they work.</p>

<!--more-->

<h2 id="array-from-and-array-of">Array.from() and Array.of()</h2>

<p>We&#39;re definitely familiar with Arrays as a kind of data structure which can hold a collection. But in Javascript, there are  <em>array-ish</em> objects. These are objects that have a length and look like an array, but we don&#39;t get all of our array methods, like map, reduce, or the rest of the ones we are about to go through in this blog post! This is one of the weird parts about Javascript. Some examples are the <code>arguments</code> parameter which can be used in a function (that holds a collection of all the arguments given) and collections of DOM nodes that a function like <code>document.getElementsBy...()</code> returns.</p>

<p>Prior to ES6, we would have to use one of our for loops which can be used on a non-array type, and transform each element into an array manually. But now we get these handy class methods that can create new arrays!</p>

<p><code>Array.from()</code> takes in a parameter, which is usually one of those <em>array-ish</em> objects, and turns it into an array. Some interesting use cases include... calling reduce on a function that sums up any given number of arguments (using the <code>arguments</code> parameter) or manipulating specific DOM elements like adding styles or events.</p>
<div class="highlight"><pre><code class="language-" data-lang="">function sumAll() {
    const numbers = Array.from(arguments);
    return numbers.reduce((prev, next) =&gt; prev + next, 0));
}
</code></pre></div>
<p><code>Array.of()</code> can take several parameters and uses them to create an array. When I first learned about this method, I wondered what was the difference between using <code>Array.of()</code> and <code>new Array()</code>. Why not use the constructor if we know what we want the Array to be created of?</p>

<p><code>new Array()</code> has some inconsistent behavior depending on the number of arguments you pass to it.  If we take a look at an example comparing <code>new Array()</code> and <code>Array.of()</code>, this becomes a bit more clear.</p>

<p>Passing a single value:
<code>new Array(2)</code>
Returns a new two element Array that is unpopulated:
<code>[  ,  ]</code></p>

<p>Passing more than a single value:
<code>new Array(1,2)</code>
Returns a new two element Array that is populated with those values:
<code>[1, 2]</code></p>

<p><code>Array.of()</code> , however, will always behave in the same way and create a new Array of the elements that you pass it.
<code>Array.of(2)</code>  returns <code>[2]</code>
<code>Array.of(1, 2)</code> returns <code>[1, 2]</code></p>

<p>Check out this interesting explanation and code example on Github: <a href="https://gist.github.com/rwaldron/1074126#arrayof--variable-arity-">https://gist.github.com/rwaldron/1074126#arrayof--variable-arity-</a></p>

<h2 id="find-and-findindex">.find() and .findIndex()</h2>

<p>ES6 introduces some new filtering methods that allow us to more easily find elements and indexes of those elements within arrays. It&#39;s useful for when we need to find an element within an array that can&#39;t be looked up solely by value. For example, if we are working with an array of objects like so:</p>
<div class="highlight"><pre><code class="language-" data-lang="">const produce = [
    {
        name: 'apple',
        color: 'red',
        type: 'fruit',
        stocked: true
    },
    {
        name: 'banana',
        color: 'yellow',
        type: 'fruit',
        stocked: false
    },
    {
        name: 'carrot',
        color: 'orange',
        type: 'vegetable',
        stocked: true
    }
]
</code></pre></div>
<p>If we want to get one of those objects out of the array, it&#39;s difficult without reaching into each object and looping through. With the <code>.find()</code> method, we can specify exactly what we want more easily! Let&#39;s say we want the first stocked item in produce. We can pass the method a function parameter: <code>produce.find(item =&gt; { item.stocked });</code> and we&#39;ll get back the entire object:</p>
<div class="highlight"><pre><code class="language-" data-lang="">{name: 'apple', color: 'red', type: 'fruit', stocked: true}
</code></pre></div>
<p>The same goes for <code>.findIndex()</code> , but instead of being returned the entire object or element, we will get the index of that element. In this case, <code>produce.findIndex(item =&gt; { item.stocked });</code> we would get the index <code>0</code> .</p>

<p>You may be thinking, &quot;Hey! I know another function that can do this already: <code>.indexOf()</code>!&quot; This also returns us the index of the element we are looking for. The difference lies in the parameters we pass to either function. <code>.indexOf()</code> takes a value as a parameter, and is more suited for the use case of looking for an element in a collection of all primitive types. <code>.findIndex()</code>  takes a function as a parameter, and is better for when you need to find an element that fulfills a condition. It&#39;s useful for non-primitive types like objects and when you are looking for a match that is more significant than just a value.</p>

<h2 id="some-and-every">.some() and .every()</h2>

<p>These two methods are pretty straightforward and they are a great fit for some specific use cases. Both the <code>.some()</code> and <code>.every()</code> methods take in functions which return booleans as parameters, and check if either <strong>some</strong> of the elements in the array cause the function to return true or if <strong>every</strong> element in the array returns true.</p>

<p>Let&#39;s say we have an array of numbers, and we want to know if some of the numbers are even. This is easy to write with the new <code>.some()</code> method!</p>
<div class="highlight"><pre><code class="language-" data-lang="">const nums = [2, 3, 4, 5, 6]
nums.some(num =&gt; { num % 2 === 0 });
</code></pre></div>
<p>This will return true, because some of our elements (2, 4, 6)  will return true. However, since not all of the elements return true for that function, <code>nums.every(num =&gt; { num % 2 === 0 });</code> returns false.</p>

<p>The function that you pass to <code>.some()</code> and <code>.every()</code> gets access to three parameters. The only mandatory parameter is the element itself (in our example, we are using <code>num</code>). You can also use two optional parameters - the index of that element and the entire array. This allows us to write more complex functions to use with these new Array methods.</p>

<h2 id="notes-and-thoughts">Notes and Thoughts</h2>

<p>In our discussion, everyone agreed that these new methods will be useful. It removes some of the needs to use jQuery, which can be a bigger package than you need in your project. We all thought that the <code>Array.from</code> method was very practical especially since Javascript has these weird <em>array-ish</em> objects. I really like how semantic these methods are; so many of the new ES6 features improve readability of your code - a great added benefit, especially with Javascript which can be a little crazy sometimes. It&#39;s good to see that some of the &quot;bad parts&quot; of Javascript are being combatted with new methods that make our code more maintainable and understandable. To me, it definitely feels like Javascript is heading in the right direction. How do you feel about Javascript&#39;s future? Which of these new Array methods is your favorite? What else would you like to see be added to Javascript?</p>

<p>Thanks for reading!</p>

      </div>
      <div class="tb-Post-author">
        
        
        <div class="tb-Author">
  
    <div class="tb-Author-gravatar">
      <img title="Miranda Wang" src="https://www.gravatar.com/avatar/b187b2b7ab47955a195b68f62ee6dae4?s=150"/>
    </div>
  
  <div class="tb-Author-info">
    
      <time pubdate datetime="2018-03-12T00:00:00-04:00">
        12 Mar 2018
      </time></br>
      by Miranda Wang
    
    <div class="tb-Author-icons">
      
        <span class="tb-Author-icon">
          <a href="http://twitter.com/Ch0xi"><i class="tb-Icon-twitter"></i></a>
        </span>
      
      
        <span class="tb-Author-icon">
          <a href="https://github.com/mirandawang"><i class="tb-Icon-github"></i></a>
        </span>
      
      
    </div>
    
      <div class="tb-Author-posts">
        <a href="/authors/miranda-wang" class="sb-Btn sb-Btn--secondary sb-Btn--small">
          View All Posts
        </a>
      </div>
    
  </div>
</div>

      </div>
    </div>
    
  <div class="sb-Wrapper">
    <section id="disqus_thread">
    </section>
  </div>
  <script type="text/javascript">
    var disqus_shortname = 'custominktechnologyblog';
    var disqus_identifier = '/blog/2018/03/12/learning-es6-new-methods-for-arrays/';
    var disqus_title = "Learning ES6: New Methods for Arrays";
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>


    <div class="tb-Footer">
  <div><small>&copy; 2018 CustomInk, LLC. All rights reserved.</small></div>
  <div><small><a href="http://customink.com">CustomInk</a> is a registered trademark of CustomInk LLC. "T-shirts Unite!" and the "Inky" octopus are trademarks of CustomInk, LLC.</small></div>
</div>

    
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-32456448-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


    <script src="/assets/app-9b22a82c5e39b6e35faf56501565196c2778184fa749c44436f639b4986f61bc.js" type="text/javascript"></script>
  </body>
</html>
